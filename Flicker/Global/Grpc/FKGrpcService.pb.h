// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: FKGrpcService.proto
// Protobuf C++ Version: 5.29.3

#ifndef FKGrpcService_2eproto_2epb_2eh
#define FKGrpcService_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_FKGrpcService_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_FKGrpcService_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_FKGrpcService_2eproto;
namespace im {
namespace service {
class AuthenticateLoginRequest;
struct AuthenticateLoginRequestDefaultTypeInternal;
extern AuthenticateLoginRequestDefaultTypeInternal _AuthenticateLoginRequest_default_instance_;
class AuthenticateLoginResponse;
struct AuthenticateLoginResponseDefaultTypeInternal;
extern AuthenticateLoginResponseDefaultTypeInternal _AuthenticateLoginResponse_default_instance_;
class ChatServerInfo;
struct ChatServerInfoDefaultTypeInternal;
extern ChatServerInfoDefaultTypeInternal _ChatServerInfo_default_instance_;
class GenerateTokenRequest;
struct GenerateTokenRequestDefaultTypeInternal;
extern GenerateTokenRequestDefaultTypeInternal _GenerateTokenRequest_default_instance_;
class GenerateTokenResponse;
struct GenerateTokenResponseDefaultTypeInternal;
extern GenerateTokenResponseDefaultTypeInternal _GenerateTokenResponse_default_instance_;
class ValidateTokenRequest;
struct ValidateTokenRequestDefaultTypeInternal;
extern ValidateTokenRequestDefaultTypeInternal _ValidateTokenRequest_default_instance_;
class ValidateTokenResponse;
struct ValidateTokenResponseDefaultTypeInternal;
extern ValidateTokenResponseDefaultTypeInternal _ValidateTokenResponse_default_instance_;
}  // namespace service
}  // namespace im
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace im {
namespace service {
enum StatusCode : int {
  unknown = 0,
  continue_ = 100,
  switching_protocols = 101,
  processing = 102,
  early_hints = 103,
  ok = 200,
  created = 201,
  accepted = 202,
  non_authoritative_information = 203,
  no_content = 204,
  reset_content = 205,
  partial_content = 206,
  multi_status = 207,
  already_reported = 208,
  im_used = 226,
  multiple_choices = 300,
  moved_permanently = 301,
  found = 302,
  see_other = 303,
  not_modified = 304,
  use_proxy = 305,
  temporary_redirect = 307,
  permanent_redirect = 308,
  bad_request = 400,
  unauthorized = 401,
  payment_required = 402,
  forbidden = 403,
  not_found = 404,
  method_not_allowed = 405,
  not_acceptable = 406,
  proxy_authentication_required = 407,
  request_timeout = 408,
  conflict = 409,
  gone = 410,
  length_required = 411,
  precondition_failed = 412,
  payload_too_large = 413,
  uri_too_long = 414,
  unsupported_media_type = 415,
  range_not_satisfiable = 416,
  expectation_failed = 417,
  i_am_a_teapot = 418,
  misdirected_request = 421,
  unprocessable_entity = 422,
  locked = 423,
  failed_dependency = 424,
  too_early = 425,
  upgrade_required = 426,
  precondition_required = 428,
  too_many_requests = 429,
  request_header_fields_too_large = 431,
  unavailable_for_legal_reasons = 451,
  internal_server_error = 500,
  not_implemented = 501,
  bad_gateway = 502,
  service_unavailable = 503,
  gateway_timeout = 504,
  http_version_not_supported = 505,
  variant_also_negotiates = 506,
  insufficient_storage = 507,
  loop_detected = 508,
  not_extended = 510,
  network_authentication_required = 511,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StatusCode_IsValid(int value);
extern const uint32_t StatusCode_internal_data_[];
constexpr StatusCode StatusCode_MIN = static_cast<StatusCode>(0);
constexpr StatusCode StatusCode_MAX = static_cast<StatusCode>(511);
constexpr int StatusCode_ARRAYSIZE = 511 + 1;
const ::google::protobuf::EnumDescriptor*
StatusCode_descriptor();
template <typename T>
const std::string& StatusCode_Name(T value) {
  static_assert(std::is_same<T, StatusCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StatusCode_Name().");
  return ::google::protobuf::internal::NameOfEnum(StatusCode_descriptor(), value);
}
inline bool StatusCode_Parse(absl::string_view name, StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusCode>(
      StatusCode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ValidateTokenResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.service.ValidateTokenResponse) */ {
 public:
  inline ValidateTokenResponse() : ValidateTokenResponse(nullptr) {}
  ~ValidateTokenResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ValidateTokenResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ValidateTokenResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateTokenResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ValidateTokenResponse(const ValidateTokenResponse& from) : ValidateTokenResponse(nullptr, from) {}
  inline ValidateTokenResponse(ValidateTokenResponse&& from) noexcept
      : ValidateTokenResponse(nullptr, std::move(from)) {}
  inline ValidateTokenResponse& operator=(const ValidateTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateTokenResponse& operator=(ValidateTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateTokenResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateTokenResponse*>(
        &_ValidateTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ValidateTokenResponse& a, ValidateTokenResponse& b) { a.Swap(&b); }
  inline void Swap(ValidateTokenResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateTokenResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateTokenResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ValidateTokenResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidateTokenResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValidateTokenResponse& from) { ValidateTokenResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ValidateTokenResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.service.ValidateTokenResponse"; }

 protected:
  explicit ValidateTokenResponse(::google::protobuf::Arena* arena);
  ValidateTokenResponse(::google::protobuf::Arena* arena, const ValidateTokenResponse& from);
  ValidateTokenResponse(::google::protobuf::Arena* arena, ValidateTokenResponse&& from) noexcept
      : ValidateTokenResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorDetailFieldNumber = 2,
    kUserUuidFieldNumber = 3,
    kExpiresAtFieldNumber = 4,
    kStatusFieldNumber = 1,
  };
  // string error_detail = 2;
  void clear_error_detail() ;
  const std::string& error_detail() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_detail(Arg_&& arg, Args_... args);
  std::string* mutable_error_detail();
  PROTOBUF_NODISCARD std::string* release_error_detail();
  void set_allocated_error_detail(std::string* value);

  private:
  const std::string& _internal_error_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_detail(
      const std::string& value);
  std::string* _internal_mutable_error_detail();

  public:
  // string user_uuid = 3;
  void clear_user_uuid() ;
  const std::string& user_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_user_uuid();
  PROTOBUF_NODISCARD std::string* release_user_uuid();
  void set_allocated_user_uuid(std::string* value);

  private:
  const std::string& _internal_user_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_uuid(
      const std::string& value);
  std::string* _internal_mutable_user_uuid();

  public:
  // int64 expires_at = 4;
  void clear_expires_at() ;
  ::int64_t expires_at() const;
  void set_expires_at(::int64_t value);

  private:
  ::int64_t _internal_expires_at() const;
  void _internal_set_expires_at(::int64_t value);

  public:
  // .im.service.StatusCode status = 1;
  void clear_status() ;
  ::im::service::StatusCode status() const;
  void set_status(::im::service::StatusCode value);

  private:
  ::im::service::StatusCode _internal_status() const;
  void _internal_set_status(::im::service::StatusCode value);

  public:
  // @@protoc_insertion_point(class_scope:im.service.ValidateTokenResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      62, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ValidateTokenResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr error_detail_;
    ::google::protobuf::internal::ArenaStringPtr user_uuid_;
    ::int64_t expires_at_;
    int status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FKGrpcService_2eproto;
};
// -------------------------------------------------------------------

class ValidateTokenRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.service.ValidateTokenRequest) */ {
 public:
  inline ValidateTokenRequest() : ValidateTokenRequest(nullptr) {}
  ~ValidateTokenRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ValidateTokenRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ValidateTokenRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateTokenRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ValidateTokenRequest(const ValidateTokenRequest& from) : ValidateTokenRequest(nullptr, from) {}
  inline ValidateTokenRequest(ValidateTokenRequest&& from) noexcept
      : ValidateTokenRequest(nullptr, std::move(from)) {}
  inline ValidateTokenRequest& operator=(const ValidateTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateTokenRequest& operator=(ValidateTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateTokenRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateTokenRequest*>(
        &_ValidateTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ValidateTokenRequest& a, ValidateTokenRequest& b) { a.Swap(&b); }
  inline void Swap(ValidateTokenRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateTokenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateTokenRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ValidateTokenRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidateTokenRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValidateTokenRequest& from) { ValidateTokenRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ValidateTokenRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.service.ValidateTokenRequest"; }

 protected:
  explicit ValidateTokenRequest(::google::protobuf::Arena* arena);
  ValidateTokenRequest(::google::protobuf::Arena* arena, const ValidateTokenRequest& from);
  ValidateTokenRequest(::google::protobuf::Arena* arena, ValidateTokenRequest&& from) noexcept
      : ValidateTokenRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokenFieldNumber = 1,
    kClientDeviceIdFieldNumber = 2,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // string client_device_id = 2;
  void clear_client_device_id() ;
  const std::string& client_device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_device_id();
  PROTOBUF_NODISCARD std::string* release_client_device_id();
  void set_allocated_client_device_id(std::string* value);

  private:
  const std::string& _internal_client_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_device_id(
      const std::string& value);
  std::string* _internal_mutable_client_device_id();

  public:
  // @@protoc_insertion_point(class_scope:im.service.ValidateTokenRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ValidateTokenRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::internal::ArenaStringPtr client_device_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FKGrpcService_2eproto;
};
// -------------------------------------------------------------------

class GenerateTokenRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.service.GenerateTokenRequest) */ {
 public:
  inline GenerateTokenRequest() : GenerateTokenRequest(nullptr) {}
  ~GenerateTokenRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GenerateTokenRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GenerateTokenRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenerateTokenRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenerateTokenRequest(const GenerateTokenRequest& from) : GenerateTokenRequest(nullptr, from) {}
  inline GenerateTokenRequest(GenerateTokenRequest&& from) noexcept
      : GenerateTokenRequest(nullptr, std::move(from)) {}
  inline GenerateTokenRequest& operator=(const GenerateTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateTokenRequest& operator=(GenerateTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateTokenRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateTokenRequest*>(
        &_GenerateTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(GenerateTokenRequest& a, GenerateTokenRequest& b) { a.Swap(&b); }
  inline void Swap(GenerateTokenRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateTokenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateTokenRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GenerateTokenRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenerateTokenRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenerateTokenRequest& from) { GenerateTokenRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GenerateTokenRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.service.GenerateTokenRequest"; }

 protected:
  explicit GenerateTokenRequest(::google::protobuf::Arena* arena);
  GenerateTokenRequest(::google::protobuf::Arena* arena, const GenerateTokenRequest& from);
  GenerateTokenRequest(::google::protobuf::Arena* arena, GenerateTokenRequest&& from) noexcept
      : GenerateTokenRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserUuidFieldNumber = 1,
    kClientDeviceIdFieldNumber = 2,
  };
  // string user_uuid = 1;
  void clear_user_uuid() ;
  const std::string& user_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_user_uuid();
  PROTOBUF_NODISCARD std::string* release_user_uuid();
  void set_allocated_user_uuid(std::string* value);

  private:
  const std::string& _internal_user_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_uuid(
      const std::string& value);
  std::string* _internal_mutable_user_uuid();

  public:
  // string client_device_id = 2;
  void clear_client_device_id() ;
  const std::string& client_device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_device_id();
  PROTOBUF_NODISCARD std::string* release_client_device_id();
  void set_allocated_client_device_id(std::string* value);

  private:
  const std::string& _internal_client_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_device_id(
      const std::string& value);
  std::string* _internal_mutable_client_device_id();

  public:
  // @@protoc_insertion_point(class_scope:im.service.GenerateTokenRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenerateTokenRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_uuid_;
    ::google::protobuf::internal::ArenaStringPtr client_device_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FKGrpcService_2eproto;
};
// -------------------------------------------------------------------

class ChatServerInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.service.ChatServerInfo) */ {
 public:
  inline ChatServerInfo() : ChatServerInfo(nullptr) {}
  ~ChatServerInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChatServerInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChatServerInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChatServerInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChatServerInfo(const ChatServerInfo& from) : ChatServerInfo(nullptr, from) {}
  inline ChatServerInfo(ChatServerInfo&& from) noexcept
      : ChatServerInfo(nullptr, std::move(from)) {}
  inline ChatServerInfo& operator=(const ChatServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatServerInfo& operator=(ChatServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatServerInfo* internal_default_instance() {
    return reinterpret_cast<const ChatServerInfo*>(
        &_ChatServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ChatServerInfo& a, ChatServerInfo& b) { a.Swap(&b); }
  inline void Swap(ChatServerInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatServerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatServerInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChatServerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatServerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChatServerInfo& from) { ChatServerInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChatServerInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.service.ChatServerInfo"; }

 protected:
  explicit ChatServerInfo(::google::protobuf::Arena* arena);
  ChatServerInfo(::google::protobuf::Arena* arena, const ChatServerInfo& from);
  ChatServerInfo(::google::protobuf::Arena* arena, ChatServerInfo&& from) noexcept
      : ChatServerInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kZoneFieldNumber = 2,
    kHostFieldNumber = 3,
    kPortFieldNumber = 4,
    kCurrentLoadFieldNumber = 5,
    kMaxConnectionsFieldNumber = 6,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string zone = 2;
  void clear_zone() ;
  const std::string& zone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_zone(Arg_&& arg, Args_... args);
  std::string* mutable_zone();
  PROTOBUF_NODISCARD std::string* release_zone();
  void set_allocated_zone(std::string* value);

  private:
  const std::string& _internal_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zone(
      const std::string& value);
  std::string* _internal_mutable_zone();

  public:
  // string host = 3;
  void clear_host() ;
  const std::string& host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* value);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // int32 port = 4;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // int32 current_load = 5;
  void clear_current_load() ;
  ::int32_t current_load() const;
  void set_current_load(::int32_t value);

  private:
  ::int32_t _internal_current_load() const;
  void _internal_set_current_load(::int32_t value);

  public:
  // int32 max_connections = 6;
  void clear_max_connections() ;
  ::int32_t max_connections() const;
  void set_max_connections(::int32_t value);

  private:
  ::int32_t _internal_max_connections() const;
  void _internal_set_max_connections(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:im.service.ChatServerInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      44, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChatServerInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr zone_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::int32_t port_;
    ::int32_t current_load_;
    ::int32_t max_connections_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FKGrpcService_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateLoginRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.service.AuthenticateLoginRequest) */ {
 public:
  inline AuthenticateLoginRequest() : AuthenticateLoginRequest(nullptr) {}
  ~AuthenticateLoginRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AuthenticateLoginRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AuthenticateLoginRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AuthenticateLoginRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline AuthenticateLoginRequest(const AuthenticateLoginRequest& from) : AuthenticateLoginRequest(nullptr, from) {}
  inline AuthenticateLoginRequest(AuthenticateLoginRequest&& from) noexcept
      : AuthenticateLoginRequest(nullptr, std::move(from)) {}
  inline AuthenticateLoginRequest& operator=(const AuthenticateLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateLoginRequest& operator=(AuthenticateLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateLoginRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateLoginRequest*>(
        &_AuthenticateLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AuthenticateLoginRequest& a, AuthenticateLoginRequest& b) { a.Swap(&b); }
  inline void Swap(AuthenticateLoginRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateLoginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateLoginRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AuthenticateLoginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AuthenticateLoginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AuthenticateLoginRequest& from) { AuthenticateLoginRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AuthenticateLoginRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.service.AuthenticateLoginRequest"; }

 protected:
  explicit AuthenticateLoginRequest(::google::protobuf::Arena* arena);
  AuthenticateLoginRequest(::google::protobuf::Arena* arena, const AuthenticateLoginRequest& from);
  AuthenticateLoginRequest(::google::protobuf::Arena* arena, AuthenticateLoginRequest&& from) noexcept
      : AuthenticateLoginRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kHashedPasswordFieldNumber = 2,
    kEncryptedPasswordFieldNumber = 3,
    kClientDeviceIdFieldNumber = 4,
    kClientVersionFieldNumber = 5,
    kClientPlatformFieldNumber = 6,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string hashed_password = 2;
  void clear_hashed_password() ;
  const std::string& hashed_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hashed_password(Arg_&& arg, Args_... args);
  std::string* mutable_hashed_password();
  PROTOBUF_NODISCARD std::string* release_hashed_password();
  void set_allocated_hashed_password(std::string* value);

  private:
  const std::string& _internal_hashed_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hashed_password(
      const std::string& value);
  std::string* _internal_mutable_hashed_password();

  public:
  // string encrypted_password = 3;
  void clear_encrypted_password() ;
  const std::string& encrypted_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encrypted_password(Arg_&& arg, Args_... args);
  std::string* mutable_encrypted_password();
  PROTOBUF_NODISCARD std::string* release_encrypted_password();
  void set_allocated_encrypted_password(std::string* value);

  private:
  const std::string& _internal_encrypted_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_password(
      const std::string& value);
  std::string* _internal_mutable_encrypted_password();

  public:
  // string client_device_id = 4;
  void clear_client_device_id() ;
  const std::string& client_device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_device_id();
  PROTOBUF_NODISCARD std::string* release_client_device_id();
  void set_allocated_client_device_id(std::string* value);

  private:
  const std::string& _internal_client_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_device_id(
      const std::string& value);
  std::string* _internal_mutable_client_device_id();

  public:
  // string client_version = 5;
  void clear_client_version() ;
  const std::string& client_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_version(Arg_&& arg, Args_... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* value);

  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(
      const std::string& value);
  std::string* _internal_mutable_client_version();

  public:
  // string client_platform = 6;
  void clear_client_platform() ;
  const std::string& client_platform() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_platform(Arg_&& arg, Args_... args);
  std::string* mutable_client_platform();
  PROTOBUF_NODISCARD std::string* release_client_platform();
  void set_allocated_client_platform(std::string* value);

  private:
  const std::string& _internal_client_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_platform(
      const std::string& value);
  std::string* _internal_mutable_client_platform();

  public:
  // @@protoc_insertion_point(class_scope:im.service.AuthenticateLoginRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      130, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AuthenticateLoginRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr hashed_password_;
    ::google::protobuf::internal::ArenaStringPtr encrypted_password_;
    ::google::protobuf::internal::ArenaStringPtr client_device_id_;
    ::google::protobuf::internal::ArenaStringPtr client_version_;
    ::google::protobuf::internal::ArenaStringPtr client_platform_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FKGrpcService_2eproto;
};
// -------------------------------------------------------------------

class GenerateTokenResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.service.GenerateTokenResponse) */ {
 public:
  inline GenerateTokenResponse() : GenerateTokenResponse(nullptr) {}
  ~GenerateTokenResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GenerateTokenResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GenerateTokenResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenerateTokenResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenerateTokenResponse(const GenerateTokenResponse& from) : GenerateTokenResponse(nullptr, from) {}
  inline GenerateTokenResponse(GenerateTokenResponse&& from) noexcept
      : GenerateTokenResponse(nullptr, std::move(from)) {}
  inline GenerateTokenResponse& operator=(const GenerateTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateTokenResponse& operator=(GenerateTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateTokenResponse* internal_default_instance() {
    return reinterpret_cast<const GenerateTokenResponse*>(
        &_GenerateTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(GenerateTokenResponse& a, GenerateTokenResponse& b) { a.Swap(&b); }
  inline void Swap(GenerateTokenResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateTokenResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateTokenResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GenerateTokenResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenerateTokenResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenerateTokenResponse& from) { GenerateTokenResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GenerateTokenResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.service.GenerateTokenResponse"; }

 protected:
  explicit GenerateTokenResponse(::google::protobuf::Arena* arena);
  GenerateTokenResponse(::google::protobuf::Arena* arena, const GenerateTokenResponse& from);
  GenerateTokenResponse(::google::protobuf::Arena* arena, GenerateTokenResponse&& from) noexcept
      : GenerateTokenResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorDetailFieldNumber = 2,
    kTokenFieldNumber = 3,
    kChatServerInfoFieldNumber = 5,
    kExpiresAtFieldNumber = 4,
    kStatusFieldNumber = 1,
  };
  // string error_detail = 2;
  void clear_error_detail() ;
  const std::string& error_detail() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_detail(Arg_&& arg, Args_... args);
  std::string* mutable_error_detail();
  PROTOBUF_NODISCARD std::string* release_error_detail();
  void set_allocated_error_detail(std::string* value);

  private:
  const std::string& _internal_error_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_detail(
      const std::string& value);
  std::string* _internal_mutable_error_detail();

  public:
  // string token = 3;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // .im.service.ChatServerInfo chat_server_info = 5;
  bool has_chat_server_info() const;
  void clear_chat_server_info() ;
  const ::im::service::ChatServerInfo& chat_server_info() const;
  PROTOBUF_NODISCARD ::im::service::ChatServerInfo* release_chat_server_info();
  ::im::service::ChatServerInfo* mutable_chat_server_info();
  void set_allocated_chat_server_info(::im::service::ChatServerInfo* value);
  void unsafe_arena_set_allocated_chat_server_info(::im::service::ChatServerInfo* value);
  ::im::service::ChatServerInfo* unsafe_arena_release_chat_server_info();

  private:
  const ::im::service::ChatServerInfo& _internal_chat_server_info() const;
  ::im::service::ChatServerInfo* _internal_mutable_chat_server_info();

  public:
  // int64 expires_at = 4;
  void clear_expires_at() ;
  ::int64_t expires_at() const;
  void set_expires_at(::int64_t value);

  private:
  ::int64_t _internal_expires_at() const;
  void _internal_set_expires_at(::int64_t value);

  public:
  // .im.service.StatusCode status = 1;
  void clear_status() ;
  ::im::service::StatusCode status() const;
  void set_status(::im::service::StatusCode value);

  private:
  ::im::service::StatusCode _internal_status() const;
  void _internal_set_status(::im::service::StatusCode value);

  public:
  // @@protoc_insertion_point(class_scope:im.service.GenerateTokenResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      58, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenerateTokenResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_detail_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::im::service::ChatServerInfo* chat_server_info_;
    ::int64_t expires_at_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FKGrpcService_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateLoginResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.service.AuthenticateLoginResponse) */ {
 public:
  inline AuthenticateLoginResponse() : AuthenticateLoginResponse(nullptr) {}
  ~AuthenticateLoginResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AuthenticateLoginResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AuthenticateLoginResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AuthenticateLoginResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline AuthenticateLoginResponse(const AuthenticateLoginResponse& from) : AuthenticateLoginResponse(nullptr, from) {}
  inline AuthenticateLoginResponse(AuthenticateLoginResponse&& from) noexcept
      : AuthenticateLoginResponse(nullptr, std::move(from)) {}
  inline AuthenticateLoginResponse& operator=(const AuthenticateLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateLoginResponse& operator=(AuthenticateLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateLoginResponse* internal_default_instance() {
    return reinterpret_cast<const AuthenticateLoginResponse*>(
        &_AuthenticateLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(AuthenticateLoginResponse& a, AuthenticateLoginResponse& b) { a.Swap(&b); }
  inline void Swap(AuthenticateLoginResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateLoginResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateLoginResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AuthenticateLoginResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AuthenticateLoginResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AuthenticateLoginResponse& from) { AuthenticateLoginResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AuthenticateLoginResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.service.AuthenticateLoginResponse"; }

 protected:
  explicit AuthenticateLoginResponse(::google::protobuf::Arena* arena);
  AuthenticateLoginResponse(::google::protobuf::Arena* arena, const AuthenticateLoginResponse& from);
  AuthenticateLoginResponse(::google::protobuf::Arena* arena, AuthenticateLoginResponse&& from) noexcept
      : AuthenticateLoginResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorDetailFieldNumber = 2,
    kUserUuidFieldNumber = 3,
    kTokenFieldNumber = 4,
    kChatServerInfoFieldNumber = 6,
    kTokenExpiresFieldNumber = 5,
    kStatusFieldNumber = 1,
  };
  // string error_detail = 2;
  void clear_error_detail() ;
  const std::string& error_detail() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_detail(Arg_&& arg, Args_... args);
  std::string* mutable_error_detail();
  PROTOBUF_NODISCARD std::string* release_error_detail();
  void set_allocated_error_detail(std::string* value);

  private:
  const std::string& _internal_error_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_detail(
      const std::string& value);
  std::string* _internal_mutable_error_detail();

  public:
  // string user_uuid = 3;
  void clear_user_uuid() ;
  const std::string& user_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_user_uuid();
  PROTOBUF_NODISCARD std::string* release_user_uuid();
  void set_allocated_user_uuid(std::string* value);

  private:
  const std::string& _internal_user_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_uuid(
      const std::string& value);
  std::string* _internal_mutable_user_uuid();

  public:
  // string token = 4;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // .im.service.ChatServerInfo chat_server_info = 6;
  bool has_chat_server_info() const;
  void clear_chat_server_info() ;
  const ::im::service::ChatServerInfo& chat_server_info() const;
  PROTOBUF_NODISCARD ::im::service::ChatServerInfo* release_chat_server_info();
  ::im::service::ChatServerInfo* mutable_chat_server_info();
  void set_allocated_chat_server_info(::im::service::ChatServerInfo* value);
  void unsafe_arena_set_allocated_chat_server_info(::im::service::ChatServerInfo* value);
  ::im::service::ChatServerInfo* unsafe_arena_release_chat_server_info();

  private:
  const ::im::service::ChatServerInfo& _internal_chat_server_info() const;
  ::im::service::ChatServerInfo* _internal_mutable_chat_server_info();

  public:
  // int64 token_expires = 5;
  void clear_token_expires() ;
  ::int64_t token_expires() const;
  void set_token_expires(::int64_t value);

  private:
  ::int64_t _internal_token_expires() const;
  void _internal_set_token_expires(::int64_t value);

  public:
  // .im.service.StatusCode status = 1;
  void clear_status() ;
  ::im::service::StatusCode status() const;
  void set_status(::im::service::StatusCode value);

  private:
  ::im::service::StatusCode _internal_status() const;
  void _internal_set_status(::im::service::StatusCode value);

  public:
  // @@protoc_insertion_point(class_scope:im.service.AuthenticateLoginResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      71, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AuthenticateLoginResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_detail_;
    ::google::protobuf::internal::ArenaStringPtr user_uuid_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::im::service::ChatServerInfo* chat_server_info_;
    ::int64_t token_expires_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FKGrpcService_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GenerateTokenRequest

// string user_uuid = 1;
inline void GenerateTokenRequest::clear_user_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.ClearToEmpty();
}
inline const std::string& GenerateTokenRequest::user_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.GenerateTokenRequest.user_uuid)
  return _internal_user_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateTokenRequest::set_user_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.GenerateTokenRequest.user_uuid)
}
inline std::string* GenerateTokenRequest::mutable_user_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_uuid();
  // @@protoc_insertion_point(field_mutable:im.service.GenerateTokenRequest.user_uuid)
  return _s;
}
inline const std::string& GenerateTokenRequest::_internal_user_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_uuid_.Get();
}
inline void GenerateTokenRequest::_internal_set_user_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.Set(value, GetArena());
}
inline std::string* GenerateTokenRequest::_internal_mutable_user_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_uuid_.Mutable( GetArena());
}
inline std::string* GenerateTokenRequest::release_user_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.GenerateTokenRequest.user_uuid)
  return _impl_.user_uuid_.Release();
}
inline void GenerateTokenRequest::set_allocated_user_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_uuid_.IsDefault()) {
    _impl_.user_uuid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.GenerateTokenRequest.user_uuid)
}

// string client_device_id = 2;
inline void GenerateTokenRequest::clear_client_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.ClearToEmpty();
}
inline const std::string& GenerateTokenRequest::client_device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.GenerateTokenRequest.client_device_id)
  return _internal_client_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateTokenRequest::set_client_device_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.GenerateTokenRequest.client_device_id)
}
inline std::string* GenerateTokenRequest::mutable_client_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_device_id();
  // @@protoc_insertion_point(field_mutable:im.service.GenerateTokenRequest.client_device_id)
  return _s;
}
inline const std::string& GenerateTokenRequest::_internal_client_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_device_id_.Get();
}
inline void GenerateTokenRequest::_internal_set_client_device_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.Set(value, GetArena());
}
inline std::string* GenerateTokenRequest::_internal_mutable_client_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.client_device_id_.Mutable( GetArena());
}
inline std::string* GenerateTokenRequest::release_client_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.GenerateTokenRequest.client_device_id)
  return _impl_.client_device_id_.Release();
}
inline void GenerateTokenRequest::set_allocated_client_device_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.client_device_id_.IsDefault()) {
    _impl_.client_device_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.GenerateTokenRequest.client_device_id)
}

// -------------------------------------------------------------------

// GenerateTokenResponse

// .im.service.StatusCode status = 1;
inline void GenerateTokenResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::im::service::StatusCode GenerateTokenResponse::status() const {
  // @@protoc_insertion_point(field_get:im.service.GenerateTokenResponse.status)
  return _internal_status();
}
inline void GenerateTokenResponse::set_status(::im::service::StatusCode value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:im.service.GenerateTokenResponse.status)
}
inline ::im::service::StatusCode GenerateTokenResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::im::service::StatusCode>(_impl_.status_);
}
inline void GenerateTokenResponse::_internal_set_status(::im::service::StatusCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string error_detail = 2;
inline void GenerateTokenResponse::clear_error_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.ClearToEmpty();
}
inline const std::string& GenerateTokenResponse::error_detail() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.GenerateTokenResponse.error_detail)
  return _internal_error_detail();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateTokenResponse::set_error_detail(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.GenerateTokenResponse.error_detail)
}
inline std::string* GenerateTokenResponse::mutable_error_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_detail();
  // @@protoc_insertion_point(field_mutable:im.service.GenerateTokenResponse.error_detail)
  return _s;
}
inline const std::string& GenerateTokenResponse::_internal_error_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_detail_.Get();
}
inline void GenerateTokenResponse::_internal_set_error_detail(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.Set(value, GetArena());
}
inline std::string* GenerateTokenResponse::_internal_mutable_error_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_detail_.Mutable( GetArena());
}
inline std::string* GenerateTokenResponse::release_error_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.GenerateTokenResponse.error_detail)
  return _impl_.error_detail_.Release();
}
inline void GenerateTokenResponse::set_allocated_error_detail(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_detail_.IsDefault()) {
    _impl_.error_detail_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.GenerateTokenResponse.error_detail)
}

// string token = 3;
inline void GenerateTokenResponse::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& GenerateTokenResponse::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.GenerateTokenResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateTokenResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.GenerateTokenResponse.token)
}
inline std::string* GenerateTokenResponse::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:im.service.GenerateTokenResponse.token)
  return _s;
}
inline const std::string& GenerateTokenResponse::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void GenerateTokenResponse::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* GenerateTokenResponse::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* GenerateTokenResponse::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.GenerateTokenResponse.token)
  return _impl_.token_.Release();
}
inline void GenerateTokenResponse::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.GenerateTokenResponse.token)
}

// int64 expires_at = 4;
inline void GenerateTokenResponse::clear_expires_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = ::int64_t{0};
}
inline ::int64_t GenerateTokenResponse::expires_at() const {
  // @@protoc_insertion_point(field_get:im.service.GenerateTokenResponse.expires_at)
  return _internal_expires_at();
}
inline void GenerateTokenResponse::set_expires_at(::int64_t value) {
  _internal_set_expires_at(value);
  // @@protoc_insertion_point(field_set:im.service.GenerateTokenResponse.expires_at)
}
inline ::int64_t GenerateTokenResponse::_internal_expires_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expires_at_;
}
inline void GenerateTokenResponse::_internal_set_expires_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = value;
}

// .im.service.ChatServerInfo chat_server_info = 5;
inline bool GenerateTokenResponse::has_chat_server_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chat_server_info_ != nullptr);
  return value;
}
inline void GenerateTokenResponse::clear_chat_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chat_server_info_ != nullptr) _impl_.chat_server_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::im::service::ChatServerInfo& GenerateTokenResponse::_internal_chat_server_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::service::ChatServerInfo* p = _impl_.chat_server_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::service::ChatServerInfo&>(::im::service::_ChatServerInfo_default_instance_);
}
inline const ::im::service::ChatServerInfo& GenerateTokenResponse::chat_server_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.GenerateTokenResponse.chat_server_info)
  return _internal_chat_server_info();
}
inline void GenerateTokenResponse::unsafe_arena_set_allocated_chat_server_info(::im::service::ChatServerInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chat_server_info_);
  }
  _impl_.chat_server_info_ = reinterpret_cast<::im::service::ChatServerInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.service.GenerateTokenResponse.chat_server_info)
}
inline ::im::service::ChatServerInfo* GenerateTokenResponse::release_chat_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::service::ChatServerInfo* released = _impl_.chat_server_info_;
  _impl_.chat_server_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::service::ChatServerInfo* GenerateTokenResponse::unsafe_arena_release_chat_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.GenerateTokenResponse.chat_server_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::service::ChatServerInfo* temp = _impl_.chat_server_info_;
  _impl_.chat_server_info_ = nullptr;
  return temp;
}
inline ::im::service::ChatServerInfo* GenerateTokenResponse::_internal_mutable_chat_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chat_server_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::service::ChatServerInfo>(GetArena());
    _impl_.chat_server_info_ = reinterpret_cast<::im::service::ChatServerInfo*>(p);
  }
  return _impl_.chat_server_info_;
}
inline ::im::service::ChatServerInfo* GenerateTokenResponse::mutable_chat_server_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::service::ChatServerInfo* _msg = _internal_mutable_chat_server_info();
  // @@protoc_insertion_point(field_mutable:im.service.GenerateTokenResponse.chat_server_info)
  return _msg;
}
inline void GenerateTokenResponse::set_allocated_chat_server_info(::im::service::ChatServerInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.chat_server_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.chat_server_info_ = reinterpret_cast<::im::service::ChatServerInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.service.GenerateTokenResponse.chat_server_info)
}

// -------------------------------------------------------------------

// ValidateTokenRequest

// string token = 1;
inline void ValidateTokenRequest::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& ValidateTokenRequest::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.ValidateTokenRequest.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidateTokenRequest::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.ValidateTokenRequest.token)
}
inline std::string* ValidateTokenRequest::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:im.service.ValidateTokenRequest.token)
  return _s;
}
inline const std::string& ValidateTokenRequest::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void ValidateTokenRequest::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* ValidateTokenRequest::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* ValidateTokenRequest::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.ValidateTokenRequest.token)
  return _impl_.token_.Release();
}
inline void ValidateTokenRequest::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.ValidateTokenRequest.token)
}

// string client_device_id = 2;
inline void ValidateTokenRequest::clear_client_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.ClearToEmpty();
}
inline const std::string& ValidateTokenRequest::client_device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.ValidateTokenRequest.client_device_id)
  return _internal_client_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidateTokenRequest::set_client_device_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.ValidateTokenRequest.client_device_id)
}
inline std::string* ValidateTokenRequest::mutable_client_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_device_id();
  // @@protoc_insertion_point(field_mutable:im.service.ValidateTokenRequest.client_device_id)
  return _s;
}
inline const std::string& ValidateTokenRequest::_internal_client_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_device_id_.Get();
}
inline void ValidateTokenRequest::_internal_set_client_device_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.Set(value, GetArena());
}
inline std::string* ValidateTokenRequest::_internal_mutable_client_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.client_device_id_.Mutable( GetArena());
}
inline std::string* ValidateTokenRequest::release_client_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.ValidateTokenRequest.client_device_id)
  return _impl_.client_device_id_.Release();
}
inline void ValidateTokenRequest::set_allocated_client_device_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.client_device_id_.IsDefault()) {
    _impl_.client_device_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.ValidateTokenRequest.client_device_id)
}

// -------------------------------------------------------------------

// ValidateTokenResponse

// .im.service.StatusCode status = 1;
inline void ValidateTokenResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::im::service::StatusCode ValidateTokenResponse::status() const {
  // @@protoc_insertion_point(field_get:im.service.ValidateTokenResponse.status)
  return _internal_status();
}
inline void ValidateTokenResponse::set_status(::im::service::StatusCode value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:im.service.ValidateTokenResponse.status)
}
inline ::im::service::StatusCode ValidateTokenResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::im::service::StatusCode>(_impl_.status_);
}
inline void ValidateTokenResponse::_internal_set_status(::im::service::StatusCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string error_detail = 2;
inline void ValidateTokenResponse::clear_error_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.ClearToEmpty();
}
inline const std::string& ValidateTokenResponse::error_detail() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.ValidateTokenResponse.error_detail)
  return _internal_error_detail();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidateTokenResponse::set_error_detail(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.ValidateTokenResponse.error_detail)
}
inline std::string* ValidateTokenResponse::mutable_error_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_detail();
  // @@protoc_insertion_point(field_mutable:im.service.ValidateTokenResponse.error_detail)
  return _s;
}
inline const std::string& ValidateTokenResponse::_internal_error_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_detail_.Get();
}
inline void ValidateTokenResponse::_internal_set_error_detail(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.Set(value, GetArena());
}
inline std::string* ValidateTokenResponse::_internal_mutable_error_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_detail_.Mutable( GetArena());
}
inline std::string* ValidateTokenResponse::release_error_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.ValidateTokenResponse.error_detail)
  return _impl_.error_detail_.Release();
}
inline void ValidateTokenResponse::set_allocated_error_detail(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_detail_.IsDefault()) {
    _impl_.error_detail_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.ValidateTokenResponse.error_detail)
}

// string user_uuid = 3;
inline void ValidateTokenResponse::clear_user_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.ClearToEmpty();
}
inline const std::string& ValidateTokenResponse::user_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.ValidateTokenResponse.user_uuid)
  return _internal_user_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidateTokenResponse::set_user_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.ValidateTokenResponse.user_uuid)
}
inline std::string* ValidateTokenResponse::mutable_user_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_uuid();
  // @@protoc_insertion_point(field_mutable:im.service.ValidateTokenResponse.user_uuid)
  return _s;
}
inline const std::string& ValidateTokenResponse::_internal_user_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_uuid_.Get();
}
inline void ValidateTokenResponse::_internal_set_user_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.Set(value, GetArena());
}
inline std::string* ValidateTokenResponse::_internal_mutable_user_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_uuid_.Mutable( GetArena());
}
inline std::string* ValidateTokenResponse::release_user_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.ValidateTokenResponse.user_uuid)
  return _impl_.user_uuid_.Release();
}
inline void ValidateTokenResponse::set_allocated_user_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_uuid_.IsDefault()) {
    _impl_.user_uuid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.ValidateTokenResponse.user_uuid)
}

// int64 expires_at = 4;
inline void ValidateTokenResponse::clear_expires_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = ::int64_t{0};
}
inline ::int64_t ValidateTokenResponse::expires_at() const {
  // @@protoc_insertion_point(field_get:im.service.ValidateTokenResponse.expires_at)
  return _internal_expires_at();
}
inline void ValidateTokenResponse::set_expires_at(::int64_t value) {
  _internal_set_expires_at(value);
  // @@protoc_insertion_point(field_set:im.service.ValidateTokenResponse.expires_at)
}
inline ::int64_t ValidateTokenResponse::_internal_expires_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expires_at_;
}
inline void ValidateTokenResponse::_internal_set_expires_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = value;
}

// -------------------------------------------------------------------

// AuthenticateLoginRequest

// string username = 1;
inline void AuthenticateLoginRequest::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& AuthenticateLoginRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateLoginRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginRequest.username)
}
inline std::string* AuthenticateLoginRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginRequest.username)
  return _s;
}
inline const std::string& AuthenticateLoginRequest::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void AuthenticateLoginRequest::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* AuthenticateLoginRequest::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* AuthenticateLoginRequest::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginRequest.username)
  return _impl_.username_.Release();
}
inline void AuthenticateLoginRequest::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginRequest.username)
}

// string hashed_password = 2;
inline void AuthenticateLoginRequest::clear_hashed_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hashed_password_.ClearToEmpty();
}
inline const std::string& AuthenticateLoginRequest::hashed_password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginRequest.hashed_password)
  return _internal_hashed_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateLoginRequest::set_hashed_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hashed_password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginRequest.hashed_password)
}
inline std::string* AuthenticateLoginRequest::mutable_hashed_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hashed_password();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginRequest.hashed_password)
  return _s;
}
inline const std::string& AuthenticateLoginRequest::_internal_hashed_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hashed_password_.Get();
}
inline void AuthenticateLoginRequest::_internal_set_hashed_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hashed_password_.Set(value, GetArena());
}
inline std::string* AuthenticateLoginRequest::_internal_mutable_hashed_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hashed_password_.Mutable( GetArena());
}
inline std::string* AuthenticateLoginRequest::release_hashed_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginRequest.hashed_password)
  return _impl_.hashed_password_.Release();
}
inline void AuthenticateLoginRequest::set_allocated_hashed_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hashed_password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hashed_password_.IsDefault()) {
    _impl_.hashed_password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginRequest.hashed_password)
}

// string encrypted_password = 3;
inline void AuthenticateLoginRequest::clear_encrypted_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encrypted_password_.ClearToEmpty();
}
inline const std::string& AuthenticateLoginRequest::encrypted_password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginRequest.encrypted_password)
  return _internal_encrypted_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateLoginRequest::set_encrypted_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encrypted_password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginRequest.encrypted_password)
}
inline std::string* AuthenticateLoginRequest::mutable_encrypted_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_encrypted_password();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginRequest.encrypted_password)
  return _s;
}
inline const std::string& AuthenticateLoginRequest::_internal_encrypted_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encrypted_password_.Get();
}
inline void AuthenticateLoginRequest::_internal_set_encrypted_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encrypted_password_.Set(value, GetArena());
}
inline std::string* AuthenticateLoginRequest::_internal_mutable_encrypted_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encrypted_password_.Mutable( GetArena());
}
inline std::string* AuthenticateLoginRequest::release_encrypted_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginRequest.encrypted_password)
  return _impl_.encrypted_password_.Release();
}
inline void AuthenticateLoginRequest::set_allocated_encrypted_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encrypted_password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encrypted_password_.IsDefault()) {
    _impl_.encrypted_password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginRequest.encrypted_password)
}

// string client_device_id = 4;
inline void AuthenticateLoginRequest::clear_client_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.ClearToEmpty();
}
inline const std::string& AuthenticateLoginRequest::client_device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginRequest.client_device_id)
  return _internal_client_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateLoginRequest::set_client_device_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginRequest.client_device_id)
}
inline std::string* AuthenticateLoginRequest::mutable_client_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_device_id();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginRequest.client_device_id)
  return _s;
}
inline const std::string& AuthenticateLoginRequest::_internal_client_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_device_id_.Get();
}
inline void AuthenticateLoginRequest::_internal_set_client_device_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.Set(value, GetArena());
}
inline std::string* AuthenticateLoginRequest::_internal_mutable_client_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.client_device_id_.Mutable( GetArena());
}
inline std::string* AuthenticateLoginRequest::release_client_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginRequest.client_device_id)
  return _impl_.client_device_id_.Release();
}
inline void AuthenticateLoginRequest::set_allocated_client_device_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_device_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.client_device_id_.IsDefault()) {
    _impl_.client_device_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginRequest.client_device_id)
}

// string client_version = 5;
inline void AuthenticateLoginRequest::clear_client_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_version_.ClearToEmpty();
}
inline const std::string& AuthenticateLoginRequest::client_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginRequest.client_version)
  return _internal_client_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateLoginRequest::set_client_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginRequest.client_version)
}
inline std::string* AuthenticateLoginRequest::mutable_client_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginRequest.client_version)
  return _s;
}
inline const std::string& AuthenticateLoginRequest::_internal_client_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_version_.Get();
}
inline void AuthenticateLoginRequest::_internal_set_client_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_version_.Set(value, GetArena());
}
inline std::string* AuthenticateLoginRequest::_internal_mutable_client_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.client_version_.Mutable( GetArena());
}
inline std::string* AuthenticateLoginRequest::release_client_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginRequest.client_version)
  return _impl_.client_version_.Release();
}
inline void AuthenticateLoginRequest::set_allocated_client_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.client_version_.IsDefault()) {
    _impl_.client_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginRequest.client_version)
}

// string client_platform = 6;
inline void AuthenticateLoginRequest::clear_client_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_platform_.ClearToEmpty();
}
inline const std::string& AuthenticateLoginRequest::client_platform() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginRequest.client_platform)
  return _internal_client_platform();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateLoginRequest::set_client_platform(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_platform_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginRequest.client_platform)
}
inline std::string* AuthenticateLoginRequest::mutable_client_platform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_platform();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginRequest.client_platform)
  return _s;
}
inline const std::string& AuthenticateLoginRequest::_internal_client_platform() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_platform_.Get();
}
inline void AuthenticateLoginRequest::_internal_set_client_platform(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_platform_.Set(value, GetArena());
}
inline std::string* AuthenticateLoginRequest::_internal_mutable_client_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.client_platform_.Mutable( GetArena());
}
inline std::string* AuthenticateLoginRequest::release_client_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginRequest.client_platform)
  return _impl_.client_platform_.Release();
}
inline void AuthenticateLoginRequest::set_allocated_client_platform(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_platform_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.client_platform_.IsDefault()) {
    _impl_.client_platform_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginRequest.client_platform)
}

// -------------------------------------------------------------------

// AuthenticateLoginResponse

// .im.service.StatusCode status = 1;
inline void AuthenticateLoginResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::im::service::StatusCode AuthenticateLoginResponse::status() const {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginResponse.status)
  return _internal_status();
}
inline void AuthenticateLoginResponse::set_status(::im::service::StatusCode value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginResponse.status)
}
inline ::im::service::StatusCode AuthenticateLoginResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::im::service::StatusCode>(_impl_.status_);
}
inline void AuthenticateLoginResponse::_internal_set_status(::im::service::StatusCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string error_detail = 2;
inline void AuthenticateLoginResponse::clear_error_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.ClearToEmpty();
}
inline const std::string& AuthenticateLoginResponse::error_detail() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginResponse.error_detail)
  return _internal_error_detail();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateLoginResponse::set_error_detail(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginResponse.error_detail)
}
inline std::string* AuthenticateLoginResponse::mutable_error_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_detail();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginResponse.error_detail)
  return _s;
}
inline const std::string& AuthenticateLoginResponse::_internal_error_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_detail_.Get();
}
inline void AuthenticateLoginResponse::_internal_set_error_detail(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.Set(value, GetArena());
}
inline std::string* AuthenticateLoginResponse::_internal_mutable_error_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_detail_.Mutable( GetArena());
}
inline std::string* AuthenticateLoginResponse::release_error_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginResponse.error_detail)
  return _impl_.error_detail_.Release();
}
inline void AuthenticateLoginResponse::set_allocated_error_detail(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_detail_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_detail_.IsDefault()) {
    _impl_.error_detail_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginResponse.error_detail)
}

// string user_uuid = 3;
inline void AuthenticateLoginResponse::clear_user_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.ClearToEmpty();
}
inline const std::string& AuthenticateLoginResponse::user_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginResponse.user_uuid)
  return _internal_user_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateLoginResponse::set_user_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginResponse.user_uuid)
}
inline std::string* AuthenticateLoginResponse::mutable_user_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_uuid();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginResponse.user_uuid)
  return _s;
}
inline const std::string& AuthenticateLoginResponse::_internal_user_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_uuid_.Get();
}
inline void AuthenticateLoginResponse::_internal_set_user_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.Set(value, GetArena());
}
inline std::string* AuthenticateLoginResponse::_internal_mutable_user_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_uuid_.Mutable( GetArena());
}
inline std::string* AuthenticateLoginResponse::release_user_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginResponse.user_uuid)
  return _impl_.user_uuid_.Release();
}
inline void AuthenticateLoginResponse::set_allocated_user_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_uuid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_uuid_.IsDefault()) {
    _impl_.user_uuid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginResponse.user_uuid)
}

// string token = 4;
inline void AuthenticateLoginResponse::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& AuthenticateLoginResponse::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateLoginResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginResponse.token)
}
inline std::string* AuthenticateLoginResponse::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginResponse.token)
  return _s;
}
inline const std::string& AuthenticateLoginResponse::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void AuthenticateLoginResponse::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* AuthenticateLoginResponse::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* AuthenticateLoginResponse::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginResponse.token)
  return _impl_.token_.Release();
}
inline void AuthenticateLoginResponse::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginResponse.token)
}

// int64 token_expires = 5;
inline void AuthenticateLoginResponse::clear_token_expires() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_expires_ = ::int64_t{0};
}
inline ::int64_t AuthenticateLoginResponse::token_expires() const {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginResponse.token_expires)
  return _internal_token_expires();
}
inline void AuthenticateLoginResponse::set_token_expires(::int64_t value) {
  _internal_set_token_expires(value);
  // @@protoc_insertion_point(field_set:im.service.AuthenticateLoginResponse.token_expires)
}
inline ::int64_t AuthenticateLoginResponse::_internal_token_expires() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_expires_;
}
inline void AuthenticateLoginResponse::_internal_set_token_expires(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_expires_ = value;
}

// .im.service.ChatServerInfo chat_server_info = 6;
inline bool AuthenticateLoginResponse::has_chat_server_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chat_server_info_ != nullptr);
  return value;
}
inline void AuthenticateLoginResponse::clear_chat_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chat_server_info_ != nullptr) _impl_.chat_server_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::im::service::ChatServerInfo& AuthenticateLoginResponse::_internal_chat_server_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::service::ChatServerInfo* p = _impl_.chat_server_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::service::ChatServerInfo&>(::im::service::_ChatServerInfo_default_instance_);
}
inline const ::im::service::ChatServerInfo& AuthenticateLoginResponse::chat_server_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.AuthenticateLoginResponse.chat_server_info)
  return _internal_chat_server_info();
}
inline void AuthenticateLoginResponse::unsafe_arena_set_allocated_chat_server_info(::im::service::ChatServerInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chat_server_info_);
  }
  _impl_.chat_server_info_ = reinterpret_cast<::im::service::ChatServerInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.service.AuthenticateLoginResponse.chat_server_info)
}
inline ::im::service::ChatServerInfo* AuthenticateLoginResponse::release_chat_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::service::ChatServerInfo* released = _impl_.chat_server_info_;
  _impl_.chat_server_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::service::ChatServerInfo* AuthenticateLoginResponse::unsafe_arena_release_chat_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.AuthenticateLoginResponse.chat_server_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::service::ChatServerInfo* temp = _impl_.chat_server_info_;
  _impl_.chat_server_info_ = nullptr;
  return temp;
}
inline ::im::service::ChatServerInfo* AuthenticateLoginResponse::_internal_mutable_chat_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chat_server_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::service::ChatServerInfo>(GetArena());
    _impl_.chat_server_info_ = reinterpret_cast<::im::service::ChatServerInfo*>(p);
  }
  return _impl_.chat_server_info_;
}
inline ::im::service::ChatServerInfo* AuthenticateLoginResponse::mutable_chat_server_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::service::ChatServerInfo* _msg = _internal_mutable_chat_server_info();
  // @@protoc_insertion_point(field_mutable:im.service.AuthenticateLoginResponse.chat_server_info)
  return _msg;
}
inline void AuthenticateLoginResponse::set_allocated_chat_server_info(::im::service::ChatServerInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.chat_server_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.chat_server_info_ = reinterpret_cast<::im::service::ChatServerInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.service.AuthenticateLoginResponse.chat_server_info)
}

// -------------------------------------------------------------------

// ChatServerInfo

// string id = 1;
inline void ChatServerInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ChatServerInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.ChatServerInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatServerInfo::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.ChatServerInfo.id)
}
inline std::string* ChatServerInfo::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:im.service.ChatServerInfo.id)
  return _s;
}
inline const std::string& ChatServerInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ChatServerInfo::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ChatServerInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ChatServerInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.ChatServerInfo.id)
  return _impl_.id_.Release();
}
inline void ChatServerInfo::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.ChatServerInfo.id)
}

// string zone = 2;
inline void ChatServerInfo::clear_zone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zone_.ClearToEmpty();
}
inline const std::string& ChatServerInfo::zone() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.ChatServerInfo.zone)
  return _internal_zone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatServerInfo::set_zone(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zone_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.ChatServerInfo.zone)
}
inline std::string* ChatServerInfo::mutable_zone() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_zone();
  // @@protoc_insertion_point(field_mutable:im.service.ChatServerInfo.zone)
  return _s;
}
inline const std::string& ChatServerInfo::_internal_zone() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.zone_.Get();
}
inline void ChatServerInfo::_internal_set_zone(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zone_.Set(value, GetArena());
}
inline std::string* ChatServerInfo::_internal_mutable_zone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.zone_.Mutable( GetArena());
}
inline std::string* ChatServerInfo::release_zone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.ChatServerInfo.zone)
  return _impl_.zone_.Release();
}
inline void ChatServerInfo::set_allocated_zone(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zone_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.zone_.IsDefault()) {
    _impl_.zone_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.ChatServerInfo.zone)
}

// string host = 3;
inline void ChatServerInfo::clear_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.ClearToEmpty();
}
inline const std::string& ChatServerInfo::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.service.ChatServerInfo.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatServerInfo::set_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.service.ChatServerInfo.host)
}
inline std::string* ChatServerInfo::mutable_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:im.service.ChatServerInfo.host)
  return _s;
}
inline const std::string& ChatServerInfo::_internal_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_.Get();
}
inline void ChatServerInfo::_internal_set_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.Set(value, GetArena());
}
inline std::string* ChatServerInfo::_internal_mutable_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.host_.Mutable( GetArena());
}
inline std::string* ChatServerInfo::release_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.service.ChatServerInfo.host)
  return _impl_.host_.Release();
}
inline void ChatServerInfo::set_allocated_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.service.ChatServerInfo.host)
}

// int32 port = 4;
inline void ChatServerInfo::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t ChatServerInfo::port() const {
  // @@protoc_insertion_point(field_get:im.service.ChatServerInfo.port)
  return _internal_port();
}
inline void ChatServerInfo::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:im.service.ChatServerInfo.port)
}
inline ::int32_t ChatServerInfo::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void ChatServerInfo::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// int32 current_load = 5;
inline void ChatServerInfo::clear_current_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_load_ = 0;
}
inline ::int32_t ChatServerInfo::current_load() const {
  // @@protoc_insertion_point(field_get:im.service.ChatServerInfo.current_load)
  return _internal_current_load();
}
inline void ChatServerInfo::set_current_load(::int32_t value) {
  _internal_set_current_load(value);
  // @@protoc_insertion_point(field_set:im.service.ChatServerInfo.current_load)
}
inline ::int32_t ChatServerInfo::_internal_current_load() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_load_;
}
inline void ChatServerInfo::_internal_set_current_load(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_load_ = value;
}

// int32 max_connections = 6;
inline void ChatServerInfo::clear_max_connections() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_connections_ = 0;
}
inline ::int32_t ChatServerInfo::max_connections() const {
  // @@protoc_insertion_point(field_get:im.service.ChatServerInfo.max_connections)
  return _internal_max_connections();
}
inline void ChatServerInfo::set_max_connections(::int32_t value) {
  _internal_set_max_connections(value);
  // @@protoc_insertion_point(field_set:im.service.ChatServerInfo.max_connections)
}
inline ::int32_t ChatServerInfo::_internal_max_connections() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_connections_;
}
inline void ChatServerInfo::_internal_set_max_connections(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_connections_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace service
}  // namespace im


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::im::service::StatusCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::im::service::StatusCode>() {
  return ::im::service::StatusCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // FKGrpcService_2eproto_2epb_2eh
